# 使用OpenFeign进行服务间调用

## 新建一个 `cloud_order` 模块

修改配置，将服务注册到之前启动的nacos中

```properties
spring.application.name=cloud_order

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=123qwe
spring.datasource.url=jdbc:mysql://192.168.1.7:3306/cloud_order?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&useSSL=false

spring.cloud.nacos.discovery.server-addr=192.168.1.7:8848
spring.cloud.nacos.discovery.username=nacos
spring.cloud.nacos.discovery.password=nacos
spring.cloud.nacos.discovery.namespace=077df503-0618-48f1-8ed8-835a8f46e5fb

spring.cloud.nacos.config.server-addr=192.168.1.7:8848
spring.cloud.nacos.config.username=nacos
spring.cloud.nacos.config.password=nacos
spring.cloud.nacos.config.namespace=077df503-0618-48f1-8ed8-835a8f46e5fb
spring.config.import=nacos:cloud_order?group=DEFAULT_GROUP
```

分别启动 cloud_auth 和 cloud_order 模块，查看nacos中服务列表，应当已经可以看到在命名空间 `dev` 中有两个服务。点击订阅者查看都是空的。

## 引入 OpenFeign 

### 添加依赖

分别在对应的 `pom.xml` 文件中添加maven坐标

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
    <version>4.2.1</version>
</dependency>
```

### 添加 `@EnableFeignClients` 注解

在各自的启动类上添加 `@EnableFeignClients` 

```java CloudAuthApplication.java
package top.wmd;

import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.cloud.openfeign.EnableFeignClients;

@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
@RefreshScope
public class CloudAuthApplication {

    @Value("${test.key}")
    private String testKey;

    public static void main(String[] args) {
        SpringApplication.run(CloudAuthApplication.class, args);
    }

    @PostConstruct
    public void init() {
        System.out.println("test.key: " + testKey);
    }

}

```



```java CloudOrderApplication.java
package top.wmd;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
@MapperScan("top.wmd.mapper")
public class CloudOrderApplication {

    public static void main(String[] args) {
        SpringApplication.run(CloudOrderApplication.class, args);
    }

}

```

### 在 `cloud_auth` 模块中增加对外API

在数据库中增加 `users` 表

```sql user
CREATE TABLE users (
    -- 主键和基础标识
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID',
    uuid CHAR(36) NOT NULL UNIQUE COMMENT '用户UUID',
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
    email VARCHAR(100) NOT NULL UNIQUE COMMENT '邮箱',
    phone VARCHAR(20) NULL UNIQUE COMMENT '手机号',
    
    -- 密码和安全相关
    password_hash VARCHAR(255) NOT NULL COMMENT '密码哈希',
    salt VARCHAR(32) NOT NULL COMMENT '密码盐值',
    
    -- 用户状态
    status TINYINT NOT NULL DEFAULT 1 COMMENT '用户状态: 0-禁用, 1-正常, 2-未激活, 3-锁定',
    email_verified TINYINT(1) NOT NULL DEFAULT 0 COMMENT '邮箱验证状态',
    phone_verified TINYINT(1) NOT NULL DEFAULT 0 COMMENT '手机验证状态',
    
    -- 个人信息
    nickname VARCHAR(50) NULL COMMENT '昵称',
    avatar VARCHAR(255) NULL COMMENT '头像URL',
    real_name VARCHAR(50) NULL COMMENT '真实姓名',
    gender TINYINT NULL COMMENT '性别: 0-未知, 1-男, 2-女',
    birthday DATE NULL COMMENT '生日',
    
    -- 时间戳
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    last_login_at TIMESTAMP NULL COMMENT '最后登录时间',
    email_verified_at TIMESTAMP NULL COMMENT '邮箱验证时间',
    
    -- 索引
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_phone (phone),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户表';
```

在代码中创建对应的 `User` 实体类，引入 `mybatis-plus` 依赖

```xml pom.xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-spring-boot3-starter</artifactId>
    <version>3.5.9</version>
</dependency>
```

创建接口层

```java UserApi.java
package top.wmd.api;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import top.wmd.entity.User;
import top.wmd.service.UserService;

/**
 * @author WMD001
 */
@RestController
@RequestMapping("/users")
public class UserApi {

    @Autowired
    private UserService userService;

    /**
     * 根据用户ID获取用户信息
     *
     * @param id 用户ID
     * @return 用户信息
     */
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.getUserById(id);
    }

    /**
     * 根据用户邮箱获取用户信息
     *
     * @param email 用户邮箱
     * @return 用户信息
     */
    @GetMapping("/email/{email}")
    public User getUserByEmail(@PathVariable String email) {
        return userService.getUserByEmail(email);
    }

    /**
     * 用户注册
     *
     * @param user 用户信息
     * @return 是否注册成功
     */
    @PostMapping
    public boolean register(@RequestBody User user) {
        return userService.register(user);
    }

    /**
     * 删除用户
     *
     * @param id 用户ID
     * @return 是否删除成功
     */
    @DeleteMapping("/{id}")
    public boolean deleteUser(@PathVariable Long id) {
        return userService.deleteUser(id);
    }
}
```

创建对应的 UserMapper.java 和 UserService.java以及实现类，这一步通过通义灵码实现。完成后重启服务。

## 创建调用 Client

在 `cloud_order` 中创建 `top.wmd.feign` 包，在包下创建 `AuthFeignClient.java`

```java AuthFeignClient.java
package top.wmd.feign;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import top.wmd.entity.User;

/**
 * 模块下需要有User实体类
 * @author WMD001
 */
@FeignClient(name = "cloud-auth")
public interface AuthFeignClient {

    /**
     * 根据用户ID获取用户信息
     *
     * @param id 用户ID
     * @return 用户信息
     */
    @GetMapping("/users/{id}")
    User getUserById(@PathVariable("id") Long id);

    /**
     * 根据用户邮箱获取用户信息
     *
     * @param email 用户邮箱
     * @return 用户信息
     */
    @GetMapping("/users/email/{email}")
    User getUserByEmail(@PathVariable("email") String email);
}
```

创建 `TestFeignApi.java` 

```java TestFeignApi.java
package top.wmd.api;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import top.wmd.entity.User;
import top.wmd.feign.AuthFeignClient;

/**
 * @author WMD001
 */
@RestController
public class TestFeignApi {


    @Autowired
    private AuthFeignClient authFeignClient;


    @GetMapping("/users/{id}")
    public User getUserById(@PathVariable Long id) {
        return authFeignClient.getUserById(id);
    }

    @GetMapping("/users/email/{email}")
    public User getUserByEmail(@PathVariable String email) {
        return authFeignClient.getUserByEmail(email);
    }

}
```

启动 `cloud_order` 模块时报错，`No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-loadbalancer?` 查看 openfeign 的pom文件中，发现有对应的 `loadbalance ` 依赖，但是设置了 `<optional>true</optional>` ，这就意味不会进行依赖传递，需要手动添加依赖。

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
    <version>4.2.1</version>
</dependency>
```

## 验证调用

首先往 `cloud_auth` 中插入一条数据

```sql
INSERT INTO users (uuid, username, email, password_hash, salt, nickname) 
VALUES (UUID(), 'john_doe', 'john@example.com', '$2y$10$hashedpassword', 'randomsalt', 'John');
```

调用 `cloud_order` 中的接口

`GET http://localhost:8090/order/users/1` ，调用报错 500，错误信息：

```txt
feign.FeignException$ServiceUnavailable: [503] during [GET] to [http://cloud-auth/users/1] [AuthFeignClient#getUserById(Long)]: [Load balancer does not contain an instance for the service cloud-auth]
```

发现我在 `cloud_auth` 中配置的应用名称是 `cloud_auth` ，而feign调用时配置的服务名称是 `cloud-auth` 两个名称并不一致，修改feign调用时的实例名称为 `cloud_auth`，重新启动。

这次直接启动失败，报错：

```txt
java.lang.IllegalStateException: Service id not legal hostname (cloud_auth)
```

这是因为在 `loadbalancer` 中使用了 `java.net.URI` 获取主机名host，而 Java 的 `java.net.URI` 类严格遵守RFC规范，不允许主机名中包含下划线。此时获取到的 host 为 null。修改服务名称都是用连字符形式。

修改后的 `AuthFeignClient.java`

```java 
package top.wmd.feign;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import top.wmd.entity.User;

/**
 * path 参数设置公共前缀
 * @author WMD001
 */
@FeignClient(name = "cloud-auth", path = "/auth")
public interface AuthFeignClient {

    /**
     * 根据用户ID获取用户信息
     *
     * @param id 用户ID
     * @return 用户信息
     */
    @GetMapping("/users/{id}")
    User getUserById(@PathVariable("id") Long id);

    /**
     * 根据用户邮箱获取用户信息
     *
     * @param email 用户邮箱
     * @return 用户信息
     */
    @GetMapping("/users/email/{email}")
    User getUserByEmail(@PathVariable("email") String email);
}
```

此时，再进行http调用，返回200

```txt
###
GET http://localhost:8090/order/users/1

返回结果：
{
  "id": 1,
  "uuid": "f99c67c0-bcb8-11f0-bdb8-1c697ab6364e",
  "username": "john_doe",
  "email": "john@example.com",
  "phone": null,
  "passwordHash": "$2y$10$hashedpassword",
  "salt": "randomsalt",
  "status": 1,
  "emailVerified": false,
  "phoneVerified": false,
  "nickname": "John",
  "avatar": null,
  "realName": null,
  "gender": null,
  "birthday": null,
  "createdAt": "2025-11-08T15:38:29.000+00:00",
  "updatedAt": "2025-11-08T15:38:29.000+00:00",
  "lastLoginAt": null,
  "emailVerifiedAt": null
}
```

## 调用异常处理

在上一个步骤中，我们已经完成了一次服务间调用，但是调用过程并不顺利，那么我们应该如何优雅的处理异常呢？比如：调用的服务不存在，或者服务调用超时，或者服务调用失败等等。

### 异常情况

#### 服务不存在

抛出异常：`FeignException$ServiceUnavailable` ，表示服务不可用，找不到对应的实例

```txt
feign.FeignException$ServiceUnavailable: [503] during [GET] to [http://cloud-auth/auth/users/1] [AuthFeignClient#getUserById(Long)]: [Load balancer does not contain an instance for the service cloud-auth]
	at feign.FeignException.serverErrorStatus(FeignException.java:287) ~[feign-core-13.5.jar:na]
	at feign.FeignException.errorStatus(FeignException.java:226) ~[feign-core-13.5.jar:na]
	at feign.FeignException.errorStatus(FeignException.java:213) ~[feign-core-13.5.jar:na]
	at feign.codec.ErrorDecoder$Default.decode(ErrorDecoder.java:103) ~[feign-core-13.5.jar:na]
	...
```

#### 调用服务超时

修改 `cloud-auth` 服务中的 `UserApi.java` 增加线程阻断时间。

```java
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            // ignore
        }
        return userService.getUserById(id);
    }
```

此时再调用 `cloud-order` 将会抛出 `java.net.SocketTimeoutException: Read timed out` 

OpenFeign 使用两个超时参数

- `connectTimeout` 连接超时时间，连接创建超时设置，可能是网络原因导致。默认10秒
- `readTimeout` 连接读取时间，连接建立后从连接中获取响应的超时时间，可能是程序长时间处理导致。默认60秒

配置文件选项

```properties
### openfeign 默认超时时间配置 default 对所有配置生效，也可以指定具体 client 名称
spring.cloud.openfeign.client.config.default.connect-timeout=1000
spring.cloud.openfeign.client.config.default.read-timeout=1000
```

openfeign 默认使用 `URLConnection` 创建http连接，可以选择使用 `httpclient`或者 `okhttp`

使用 `Apathe httpclient`

引入依赖，使用 `httpclient5`：

```xml
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-hc5</artifactId>
</dependency>
```

配置文件：

```properties
### 启用 apache httpclient，默认配置依然可以生效
spring.cloud.openfeign.httpclient.hc5.enabled=true
```

> 从 Spring Cloud OpenFeign 4 开始，不再支持 Feign Apache HttpClient 4。我们建议改用 Apache HttpClient 5。

使用 `okhttp`

引入依赖

```XML
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-okhttp</artifactId>
</dependency>
```

配置文件：

```properties
### 启用 okhttp，默认配置依然生效
spring.cloud.openfeign.okhttp.enabled=true
```

#### 调用服务异常

在 `cloud-auth` 中手动抛出一个异常

```java
   @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            // ignore
        }
        if (id == 1) {
            throw new RuntimeException("服务响应异常");
        }
        return userService.getUserById(id);
    }
```

在 `cloud-order` 中调用抛出异常 `FeignException$InternalServerError`

```txt
feign.FeignException$InternalServerError: [500] during [GET] to [http://cloud-auth/auth/users/1] [AuthFeignClient#getUserById(Long)]: [{"timestamp":"2025-11-10T15:21:22.931+00:00","status":500,"error":"Internal Server Error","path":"/auth/users/1"}]
	at feign.FeignException.serverErrorStatus(FeignException.java:281) ~[feign-core-13.5.jar:na]
	at feign.FeignException.errorStatus(FeignException.java:226) ~[feign-core-13.5.jar:na]
	at feign.FeignException.errorStatus(FeignException.java:213) ~[feign-core-13.5.jar:na]
	...
```

### 异常处理

#### 失败重试

Spring Cloud OpenFeign 默认不开启重试机制，默认使用的是 `Retryer.NEVER_RETRY` ，需要手动创建一个 `Retryer` 的 Bean。

创建配置类

```java
package top.wmd.config;

import feign.Retryer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * openfeign 配置类
 * @author WMD001
 */
@Configuration
public class AuthClientConfig {


    @Bean
    public Retryer authRetryer() {
        /*
         * 1000 初始重试间隔（毫秒），即第一次重试前等待的时间
         * 最大重试间隔（毫秒），即使指数增长也不能超过此值
         * 最大尝试次数（包括首次请求）
         */
        return new Retryer.Default(1000, 10000, 3);
    }


}
```



在 `@FeignClient` 注解中添加参数

```java
package top.wmd.feign;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import top.wmd.config.AuthClientConfig;
import top.wmd.entity.User;

/**
 * path 参数设置公共前缀
 * configuration 指定配置类
 * @author WMD001
 */
@FeignClient(name = "cloud-auth", path = "/auth", configuration=AuthClientConfig.class)
public interface AuthFeignClient {

    /**
     * 根据用户ID获取用户信息
     *
     * @param id 用户ID
     * @return 用户信息
     */
    @GetMapping("/users/{id}")
    User getUserById(@PathVariable("id") Long id);

    /**
     * 根据用户邮箱获取用户信息
     *
     * @param email 用户邮箱
     * @return 用户信息
     */
    @GetMapping("/users/email/{email}")
    User getUserByEmail(@PathVariable("email") String email);
}
```

此时，在 `cloud-auth` 服务中手动抛出 `RuntimeException` ，观察调用情况。

```java
    @GetMapping("/{id}")
    public Object getUser(@PathVariable Long id) {
        System.out.println("收到调用：" + LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME));
        if (id == 1) {
            // 手动抛出异常
            throw new RuntimeException("服务响应异常");
        }
        return userService.getUserById(id);
    }
```

调用后发现，请求日志只打印了一次，调用返回了失败，但是并没有进行重试。这是因为  `OpenFeign` 只会对请求发起，连接建立过程中的异常进行重试，而服务内部虽然抛出了异常，但是请求连接已经建立，而且返回500状态码，客户端收到的是一个 “成功的HTTP响应”，而不是网络异常，因此不会触发重试。手动关闭 `cloud-auth` 服务后，发现请求后并不会立即返回失败，而是会等待一会，即重试请求。

> 测试过程中，当两个服务都未启动时，此时只启动 `cloud-order` 服务，调用并没有触发重试；而当两个服务都成功启动后，手动关闭 `cloud-auth` 服务，此时调用将会触发重试；而 `cloud-auth` 长时间未重新启动，此时再调用也不会触发重试。
>
> 原因：当服务未注册到nacos，或者注册后又下线，此时由于 LoadBalancer 会由于找不到可用实例而直接抛出异常，并不会进行feign调用，自然也不会触发请求重试。

#### 请求拦截器

**请求拦截器**可以对请求添加统一的参数处理，例如在请求header中增加token信息。创建拦截器 `FeignClientInterceptor` 实现 `RequestInterceptor` ，添加 `@Component` 注入到Spring容器中

```java
package top.wmd.config;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

/**
 * @author WMD001
 */
@Slf4j
@Component
public class FeignClientInterceptor implements RequestInterceptor {

    @Override
    public void apply(RequestTemplate template) {
        //  统一放入请求header
        template.header("Authorization", "Bearer " + "123");
    }

}
```

修改 `cloud-auth` 被调用方法，读取 Request header 中的 `Authorization`

```java
    @GetMapping("/{id}")
    public Object getUser(@PathVariable Long id, HttpServletRequest request) {
        String authorization = request.getHeader("Authorization");
        log.info("收到调用, header-auth: {}", authorization);
        return userService.getUserById(id);
    }
```

> 多个拦截器可以同时使用，可以使用 `@Order` 指定顺序

#### 服务降级

`@FeignClient` 提供 `fallback` 参数进行降级处理。需要配合熔断器使用。这里选择阿里开源的 **Sentinel**。

引入依赖：

```xml
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
            <version>2023.0.3.2</version>
        </dependency>
```

开启配置：

```properties application.properties
feign.sentinel.enabled=true
```

增加降级处理类 `AuthClientFallback.java` 实现 `AuthFeignClient.java` 方法签名要保持一致，在对应的方法中编写降级处理逻辑：

```java
package top.wmd.config;


import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import top.wmd.entity.User;
import top.wmd.feign.AuthFeignClient;

/**
 * feign 降级处理
 * @author WMD001
 */
@Slf4j
@Component
public class AuthClientFallback implements AuthFeignClient {

    @Override
    public User getUserById(Long id) {
        log.info("getUserById fallback");
        User user = new User();
        user.setId(id);
        user.setNickname("fallback");
        return user;
    }

    @Override
    public User getUserByEmail(String email) {
        return null;
    }
}

```

`AuthFeignClient.java` 类上增加 **fallback** 配置：

```java
package top.wmd.feign;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import top.wmd.config.AuthClientConfig;
import top.wmd.config.AuthClientFallback;
import top.wmd.entity.User;

/**
 * path 参数设置公共前缀
 * configuration 指定配置类
 * fallback 指定降级处理类
 * @author WMD001
 */
@FeignClient(name = "cloud-auth", path = "/auth", configuration=AuthClientConfig.class, fallback = AuthClientFallback.class)
public interface AuthFeignClient {

    /**
     * 根据用户ID获取用户信息
     *
     * @param id 用户ID
     * @return 用户信息
     */
    @GetMapping("/users/{id}")
    User getUserById(@PathVariable("id") Long id);

    /**
     * 根据用户邮箱获取用户信息
     *
     * @param email 用户邮箱
     * @return 用户信息
     */
    @GetMapping("/users/email/{email}")
    User getUserByEmail(@PathVariable("email") String email);
}
```

只启动 `cloud-order` 服务，此时调用请求响应成功，返回的是降级处理类中的返回对象。

> **fallback** 和 **Retryer** 同时开启时，Feign 会先执行所有重试（由 `Retryer` 控制），只有在重试耗尽仍失败时，才会触发 fallback

